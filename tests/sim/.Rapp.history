var(rhohat)
se
sqrt(var(rhohat))
library(sandwich)#
n <- 100#
nMC <- 10000#
b <- 0#
#
rhohat <- rep(NA,nMC); hc0 <- rhohat; hc1 <- hc0; hc2 <- hc0; hc3 <- hc0; se <- hc0; rhohat.ols <- rhohat#
for (mc in 1:nMC) {#
    X <- rnorm(n)#
    Y <- b*X + rnorm(n)#
    rhohat[mc] <- spearman(Y,X)#
#
    res <- rrreg(Y, X)#
    hc0[mc] <- res$hc0#
    hc1[mc] <- res$hc1#
    hc2[mc] <- res$hc2#
    hc3[mc] <- res$hc3#
    se[mc] <- res$se#
    rhohat.ols[mc] <- res$rhohat#
}#
print(paste("simulated SE of Spearman's rho: ", sqrt(var(rhohat))))#
#
print(paste("OLS SE under homosked.: ", mean(se)))#
print(paste("OLS with White SE: ", mean(hc0)))#
print(paste("OLS with HC1 SE: ", mean(hc1)))#
print(paste("OLS with HC2 SE: ", mean(hc2)))#
print(paste("OLS with HC3 SE: ", mean(hc3)))
library(sandwich)#
n <- 1000#
nMC <- 10000#
b <- 0#
#
rhohat <- rep(NA,nMC); hc0 <- rhohat; hc1 <- hc0; hc2 <- hc0; hc3 <- hc0; se <- hc0; rhohat.ols <- rhohat#
for (mc in 1:nMC) {#
    X <- rnorm(n)#
    Y <- b*X + rnorm(n)#
    rhohat[mc] <- spearman(Y,X)#
#
    res <- rrreg(Y, X)#
    hc0[mc] <- res$hc0#
    hc1[mc] <- res$hc1#
    hc2[mc] <- res$hc2#
    hc3[mc] <- res$hc3#
    se[mc] <- res$se#
    rhohat.ols[mc] <- res$rhohat#
}#
print(paste("simulated SE of Spearman's rho: ", sqrt(var(rhohat))))#
#
print(paste("OLS SE under homosked.: ", mean(se)))#
print(paste("OLS with White SE: ", mean(hc0)))#
print(paste("OLS with HC1 SE: ", mean(hc1)))#
print(paste("OLS with HC2 SE: ", mean(hc2)))#
print(paste("OLS with HC3 SE: ", mean(hc3)))
rbind(list(a=0,b=3),list(a=2,b=8)
)
list(a=2,b=8)
rl <- list(a=2,b=8)
rl$c=9
rl
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
nocores <- detectCores()-1#
registerDoMC(nocores)#
#
n <- c(100,1000)#
nMC <- 10000#
b <- seq(0,2,length=3)#
#
params <- expand.table(n=n, b=b)#
nparams <- nrow(params)
params <- expand.grid(n=n, b=b)
nparams <- nrow(params)
n <- c(10,100)#
nMC <- 100#
b <- seq(0,2,length=3)#
#
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    for (mc in 1:nMC) {#
        X <- rnorm(params$n[i])#
        Y <- params$b[i]*X + rnorm(params$n[i])#
        rrres <- rrreg(Y, X)#
        rrres$spearman <- spearman(Y,X)#
    }#
    list(spearman=sd(rrres$spearman), se=mean(rrres$se), white=mean(rrres$hc0))#
}
res
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rrres <- NULL#
    for (mc in 1:nMC) {#
        X <- rnorm(params$n[i])#
        Y <- params$b[i]*X + rnorm(params$n[i])#
        tmp <- rrreg(Y, X)#
        tmp$spearman <- spearman(Y,X)#
        rrres <- rbind(rrres,tmp)#
    }#
    list(spearman=sd(rrres$spearman), se=mean(rrres$se), white=mean(rrres$hc0))#
}
res
rres
rrres
tmp
i <- 1
rrres <- NULL
for (mc in 1:nMC) {#
        X <- rnorm(params$n[i])#
        Y <- params$b[i]*X + rnorm(params$n[i])#
        tmp <- rrreg(Y, X)#
        tmp$spearman <- spearman(Y,X)#
        rrres <- rbind(rrres,tmp)#
    }
rrres
list(spearman=sd(rrres$spearman), se=mean(rrres$se), white=mean(rrres$hc0))
sd(rrres$spearman)
rrres$spearman
names(rrres)
rrres
data.frame(rrres)
data.frame(rrres)$spearman
list(a=3,b=2)
unlist(list(a=3,b=2))
rrres <- NULL#
    for (mc in 1:nMC) {#
        X <- rnorm(params$n[i])#
        Y <- params$b[i]*X + rnorm(params$n[i])#
        tmp <- rrreg(Y, X)#
        tmp$spearman <- spearman(Y,X)#
        rrres <- rbind(rrres,unlist(tmp))#
    }
rrres
rrres$spearman
rrreg <- function(Y, X) {#
    FYn <- ecdf(Y)#
    RY <- FYn(Y)        #
    FXn <- ecdf(X)#
    RX <- FXn(X)        #
    res <- lm(RY ~ RX)#
    rhohat <- coef(summary(res))[2,1]#
    se <- coef(summary(res))[2,2]#
    hc0 <- sqrt(vcovHC(res, type="HC0")[2,2])#
    return(list(rhohat=rhohat,se=se,hc0=hc0))#
}#
#
spearman <- function(Y, X) return(cor(xrank(Y),xrank(X)))#
#
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
    if (na.rm) x <- x[!is.na(x)]#
    return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}
rrres <- NULL#
    for (mc in 1:nMC) {#
        X <- rnorm(params$n[i])#
        Y <- params$b[i]*X + rnorm(params$n[i])#
        tmp <- rrreg(Y, X)#
        tmp$spearman <- spearman(Y,X)#
        rrres <- rbind(rrres,unlist(tmp))#
    }
rrres
as.data.frame(rrres)
as.data.frame(rrres)$spearman
rrres <- as.data.frame(rrres)
list(spearman=sd(rrres$spearman), se=mean(rrres$se), white=mean(rrres$hc0))
c(sd(rrres$spearman), se=mean(rrres$se), white=mean(rrres$hc0))
c(spearman=sd(rrres$spearman), se=mean(rrres$se), white=mean(rrres$hc0))
as.data.frame(spearman=sd(rrres$spearman), se=mean(rrres$se), white=mean(rrres$hc0))
c(spearman=sd(rrres$spearman), se=mean(rrres$se), white=mean(rrres$hc0))
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
nocores <- detectCores()-1#
registerDoMC(nocores)#
#
n <- c(10,100)#
nMC <- 100#
b <- seq(0,2,length=3)#
#
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rrres <- NULL#
    for (mc in 1:nMC) {#
        X <- rnorm(params$n[i])#
        Y <- params$b[i]*X + rnorm(params$n[i])#
        tmp <- rrreg(Y, X)#
        tmp$spearman <- spearman(Y,X)#
        rrres <- rbind(rrres,unlist(tmp))#
    }#
    rrres <- as.data.frame(rrres)#
    c(spearman=sd(rrres$spearman), se=mean(rrres$se), white=mean(rrres$hc0))#
}
res
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rrres <- NULL#
    for (mc in 1:nMC) {#
        X <- rnorm(params$n[i])#
        Y <- params$b[i]*X + rnorm(params$n[i])#
        tmp <- rrreg(Y, X)#
        tmp$spearman <- spearman(Y,X)#
        rrres <- rbind(rrres,unlist(tmp))#
    }#
    rrres <- as.data.frame(rrres)#
    c(n=params$n[i], b=params$b[i], spearman=sd(rrres$spearman), se=mean(rrres$se), white=mean(rrres$hc0))#
}
rrres
res
rrreg <- function(Y, X) {#
    FYn <- ecdf(Y)#
    RY <- FYn(Y)        #
    FXn <- ecdf(X)#
    RX <- FXn(X)        #
    res <- lm(RY ~ RX)#
    rhohat <- coef(summary(res))[2,1]#
    se <- coef(summary(res))[2,2]#
    hc0 <- sqrt(vcovHC(res, type="HC0")[2,2])#
    return(list(rhohat=rhohat,se=se,hc0=hc0))#
}#
#
spearman <- function(Y, X) return(cor(xrank(Y),xrank(X)))#
#
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
    if (na.rm) x <- x[!is.na(x)]#
    return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}#
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
nocores <- detectCores()-1#
registerDoMC(nocores)#
#
n <- c(100,1000)#
nMC <- 1000#
b <- seq(0,2,length=3)
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rrres <- NULL#
    for (mc in 1:nMC) {#
        X <- rnorm(params$n[i])#
        Y <- params$b[i]*X + rnorm(params$n[i])#
        tmp <- rrreg(Y, X)#
        tmp$spearman <- spearman(Y,X)#
        rrres <- rbind(rrres,unlist(tmp))#
    }#
    rrres <- as.data.frame(rrres)#
    c(n=params$n[i], b=params$b[i], spearman=sd(rrres$spearman), se=mean(rrres$se), white=mean(rrres$hc0))#
}
res
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rrres <- NULL#
    for (mc in 1:nMC) {#
        X <- rnorm(params$n[i])#
        Y <- params$b[i]*X + rnorm(params$n[i])#
        tmp <- rrreg(Y, X)#
        tmp$spearman <- spearman(Y,X)#
        rrres <- rbind(rrres,unlist(tmp))#
    }#
    rrres <- as.data.frame(rrres)#
    rbind(c(n=params$n[i], b=params$b[i], method="Spearman", se=sd(rrres$spearman)),#
            c(n=params$n[i], b=params$b[i], method="OLS", se=mean(rrres$se)),#
            c(n=params$n[i], b=params$b[i], method="White", se=mean(rrres$hc0)))#
}#
#
res <- as.data.frame(res)
res
tab <- xtabs(se ~ n + b + method, data = res)
library("lattice")
xyplot(se ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)
res
res$se
res$se <- as.double(res$se)
res
res$se
tab <- xtabs(se ~ n + b + method, data = res)
ftable(tab, row.vars = c("n", "b", "method"), col.vars = "b")
xyplot(se ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)
res$b <- as.double(res$b)
xyplot(se ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)
rrreg <- function(Y, X) {#
    FYn <- ecdf(Y)#
    RY <- FYn(Y)        #
    FXn <- ecdf(X)#
    RX <- FXn(X)        #
    res <- lm(RY ~ RX)#
    rhohat <- coef(summary(res))[2,1]#
    se <- coef(summary(res))[2,2]#
    hc0 <- sqrt(vcovHC(res, type="HC0")[2,2])#
    return(list(rhohat=rhohat,se=se,hc0=hc0))#
}#
#
spearman <- function(Y, X) return(cor(xrank(Y),xrank(X)))#
#
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
    if (na.rm) x <- x[!is.na(x)]#
    return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}#
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
nocores <- detectCores()-1#
registerDoMC(nocores)#
#
n <- c(100,1000)#
nMC <- 10000#
b <- seq(0,3,length=3)#
#
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rrres <- NULL#
    for (mc in 1:nMC) {#
        X <- rnorm(params$n[i])#
        Y <- params$b[i]*X + rnorm(params$n[i])#
        tmp <- rrreg(Y, X)#
        tmp$spearman <- spearman(Y,X)#
        rrres <- rbind(rrres,unlist(tmp))#
    }#
    rrres <- as.data.frame(rrres)#
    rbind(c(n=params$n[i], b=params$b[i], method="Spearman", se=sd(rrres$spearman)),#
            c(n=params$n[i], b=params$b[i], method="OLS", se=mean(rrres$se)),#
            c(n=params$n[i], b=params$b[i], method="White", se=mean(rrres$hc0)))#
}#
#
res <- as.data.frame(res)#
res$se <- as.double(res$se)#
res$b <- as.double(res$b)#
library("lattice")#
trellis.par.set(theme = canonical.theme(color = FALSE))#
# if (SAVE) pdf(file=paste("results/power_", gamma2, ".pdf", sep=""),width=12,height=12) else quartz(width=12,height=12)#
xyplot(se ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)#
# if (SAVE) dev.off()
pdf(file="spearman_vs_ols.pdf"),width=12,height=8)#
xyplot(se ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)#
dev.off()
pdf(file="spearman_vs_ols.pdf",width=12,height=8)
xyplot(se ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)
dev.off()
res$n <- paste("n=",res$n,sep="")
trellis.par.set(theme = canonical.theme(color = FALSE))#
pdf(file="spearman_vs_ols.pdf",width=12,height=8)#
xyplot(se ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)#
dev.off()
rrreg <- function(Y, X) {#
    FYn <- ecdf(Y)#
    RY <- FYn(Y)        #
    FXn <- ecdf(X)#
    RX <- FXn(X)        #
    res <- lm(RY ~ RX)#
    rhohat <- coef(summary(res))[2,1]#
    se <- coef(summary(res))[2,2]#
    hc0 <- sqrt(vcovHC(res, type="HC0")[2,2])#
    return(list(rhohat=rhohat,se=se,hc0=hc0))#
}#
#
spearman <- function(Y, X) return(cor(xrank(Y),xrank(X)))#
#
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
    if (na.rm) x <- x[!is.na(x)]#
    return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}#
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
nocores <- detectCores()-1#
registerDoMC(nocores)#
#
n <- c(100,1000)#
nMC <- 10000#
b <- seq(0,5,length=5)#
#
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rrres <- NULL#
    for (mc in 1:nMC) {#
        X <- rnorm(params$n[i])#
        Y <- params$b[i]*X + rnorm(params$n[i])#
        tmp <- rrreg(Y, X)#
        tmp$spearman <- spearman(Y,X)#
        rrres <- rbind(rrres,unlist(tmp))#
    }#
    rrres <- as.data.frame(rrres)#
    rbind(c(n=params$n[i], b=params$b[i], method="Spearman", sd=sd(rrres$spearman)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="OLS", sd=mean(rrres$se)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="White", sd=mean(rrres$hc0)*sqrt(params$n[i])))#
}#
#
res <- as.data.frame(res)#
res$sd <- as.double(res$sd)#
res$b <- as.double(res$b)#
res$n <- paste("n=",res$n,sep="")#
library("lattice")#
trellis.par.set(theme = canonical.theme(color = FALSE))#
pdf(file="spearman_vs_ols.pdf",width=12,height=8)#
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)#
dev.off()
rrreg <- function(Y, X) {#
    FYn <- ecdf(Y)#
    RY <- FYn(Y)        #
    FXn <- ecdf(X)#
    RX <- FXn(X)        #
    res <- lm(RY ~ RX)#
    rhohat <- coef(summary(res))[2,1]#
    se <- coef(summary(res))[2,2]#
    hc0 <- sqrt(vcovHC(res, type="HC0")[2,2])#
    return(list(rhohat=rhohat,se=se,hc0=hc0))#
}#
#
spearman <- function(Y, X) return(cor(xrank(Y),xrank(X)))#
#
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
    if (na.rm) x <- x[!is.na(x)]#
    return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}#
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
nocores <- detectCores()-1#
registerDoMC(nocores)#
#
n <- c(100,1000,10000)#
nMC <- 10000#
b <- seq(0,5,length=5)#
#
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rrres <- NULL#
    for (mc in 1:nMC) {#
        X <- rnorm(params$n[i])#
        Y <- params$b[i]*X + rnorm(params$n[i])#
        tmp <- rrreg(Y, X)#
        tmp$spearman <- spearman(Y,X)#
        rrres <- rbind(rrres,unlist(tmp))#
    }#
    rrres <- as.data.frame(rrres)#
    rbind(c(n=params$n[i], b=params$b[i], method="Spearman", sd=sd(rrres$spearman)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="OLS", sd=mean(rrres$se)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="White", sd=mean(rrres$hc0)*sqrt(params$n[i])))#
}#
#
res <- as.data.frame(res)#
res$sd <- as.double(res$sd)#
res$b <- as.double(res$b)#
res$n <- paste("n=",res$n,sep="")#
library("lattice")#
trellis.par.set(theme = canonical.theme(color = FALSE))#
pdf(file="spearman_vs_ols.pdf",width=12,height=8)#
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)#
dev.off()
rrreg <- function(Y, X) {#
    FYn <- ecdf(Y)#
    RY <- FYn(Y)        #
    FXn <- ecdf(X)#
    RX <- FXn(X)        #
    res <- lm(RY ~ RX)#
    rhohat <- coef(summary(res))[2,1]#
    se <- coef(summary(res))[2,2]#
    hc0 <- sqrt(vcovHC(res, type="HC0")[2,2])#
    return(list(rhohat=rhohat,se=se,hc0=hc0))#
}#
#
spearman <- function(Y, X) return(cor(xrank(Y),xrank(X)))#
#
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
    if (na.rm) x <- x[!is.na(x)]#
    return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}#
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
nocores <- detectCores()-1#
registerDoMC(nocores)#
#
n <- c(100,10000)#
nMC <- 10000#
b <- seq(0,5,length=5)#
#
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rrres <- NULL#
    for (mc in 1:nMC) {#
        X <- rnorm(params$n[i])#
        Y <- params$b[i]*X + rnorm(params$n[i])#
        tmp <- rrreg(Y, X)#
        tmp$spearman <- spearman(Y,X)#
        rrres <- rbind(rrres,unlist(tmp))#
    }#
    rrres <- as.data.frame(rrres)#
    rbind(c(n=params$n[i], b=params$b[i], method="Spearman", sd=sd(rrres$spearman)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="OLS", sd=mean(rrres$se)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="White", sd=mean(rrres$hc0)*sqrt(params$n[i])))#
}#
#
res <- as.data.frame(res)#
res$sd <- as.double(res$sd)#
res$b <- as.double(res$b)#
res$n <- paste("n=",res$n,sep="")#
library("lattice")#
trellis.par.set(theme = canonical.theme(color = FALSE))#
pdf(file="spearman_vs_ols.pdf",width=12,height=8)#
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)#
dev.off()
rrreg <- function(Y, X) {#
    FYn <- ecdf(Y)#
    RY <- FYn(Y)        #
    FXn <- ecdf(X)#
    RX <- FXn(X)        #
    res <- lm(RY ~ RX)#
    rhohat <- coef(summary(res))[2,1]#
    se <- coef(summary(res))[2,2]#
    hc0 <- sqrt(vcovHC(res, type="HC0")[2,2])#
    return(list(rhohat=rhohat,se=se,hc0=hc0))#
}#
#
spearman <- function(Y, X) return(cor(xrank(Y),xrank(X)))#
#
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
    if (na.rm) x <- x[!is.na(x)]#
    return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}#
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
nocores <- detectCores()-1#
registerDoMC(nocores)#
#
n <- c(100,1000)#
nMC <- 10000#
b <- seq(0,5,length=5)#
#
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rrres <- NULL#
    for (mc in 1:nMC) {#
        X <- rnorm(params$n[i])#
        Y <- params$b[i]*X + rnorm(params$n[i])#
        tmp <- rrreg(Y, X)#
        tmp$spearman <- spearman(Y,X)#
        rrres <- rbind(rrres,unlist(tmp))#
    }#
    rrres <- as.data.frame(rrres)#
    rbind(c(n=params$n[i], b=params$b[i], method="Spearman", sd=sd(rrres$spearman)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="OLS", sd=mean(rrres$se)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="White", sd=mean(rrres$hc0)*sqrt(params$n[i])))#
}#
#
res <- as.data.frame(res)#
res$sd <- as.double(res$sd)#
res$b <- as.double(res$b)#
res$n <- paste("n=",res$n,sep="")#
library("lattice")#
trellis.par.set(theme = canonical.theme(color = FALSE))#
pdf(file="spearman_vs_ols.pdf",width=12,height=8)#
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)#
dev.off()
load("/Users/uctpdwi/Dropbox/shared project folders/rank-rank-reg/code/workspace.RData")
rrreg <- function(Y, X) {#
    FYn <- ecdf(Y)#
    RY <- FYn(Y)        #
    FXn <- ecdf(X)#
    RX <- FXn(X)        #
    res <- lm(RY ~ RX)#
    rhohat <- coef(summary(res))[2,1]#
    se <- coef(summary(res))[2,2]#
    hc0 <- sqrt(vcovHC(res, type="HC0")[2,2])#
    return(list(rhohat=rhohat,se=se,hc0=hc0))#
}#
#
spearman <- function(Y, X) return(cor(xrank(Y),xrank(X)))#
#
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
    if (na.rm) x <- x[!is.na(x)]#
    return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}#
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
nocores <- detectCores()#
registerDoMC(nocores)#
print(nocores)#
#
n <- c(100,1000)#
nMC <- 100#
b <- seq(0,5,length=5)#
#
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rrres <- NULL#
    for (mc in 1:nMC) {#
        X <- rnorm(params$n[i])#
        Y <- params$b[i]*X + rnorm(params$n[i])#
        tmp <- rrreg(Y, X)#
        tmp$spearman <- spearman(Y,X)#
        rrres <- rbind(rrres,unlist(tmp))#
    }#
    rrres <- as.data.frame(rrres)#
    rbind(c(n=params$n[i], b=params$b[i], method="Spearman", sd=sd(rrres$spearman)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="OLS", sd=mean(rrres$se)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="White", sd=mean(rrres$hc0)*sqrt(params$n[i])))#
}#
#
res <- as.data.frame(res)#
res$sd <- as.double(res$sd)#
res$b <- as.double(res$b)#
res$n <- paste("n=",res$n,sep="")
library("lattice")
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)
rrreg <- function(Y, X) {#
    FYn <- ecdf(Y)#
    RY <- FYn(Y)        #
    FXn <- ecdf(X)#
    RX <- FXn(X)        #
    res <- lm(RY ~ RX)#
    rhohat <- coef(summary(res))[2,1]#
    se <- coef(summary(res))[2,2]#
    hc0 <- sqrt(vcovHC(res, type="HC0")[2,2])#
    return(list(rhohat=rhohat,se=se,hc0=hc0))#
}#
#
spearman <- function(Y, X) return(cor(xrank(Y),xrank(X)))#
#
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
    if (na.rm) x <- x[!is.na(x)]#
    return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}#
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
nocores <- detectCores()#
registerDoMC(nocores)#
print(nocores)#
#
n <- c(100,1000)#
nMC <- 1000#
b <- seq(0,5,length=5)#
#
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rrres <- NULL#
    for (mc in 1:nMC) {#
        X <- rnorm(params$n[i])#
        Y <- params$b[i]*X + rnorm(params$n[i])#
        tmp <- rrreg(Y, X)#
        tmp$spearman <- spearman(Y,X)#
        rrres <- rbind(rrres,unlist(tmp))#
    }#
    rrres <- as.data.frame(rrres)#
    rbind(c(n=params$n[i], b=params$b[i], method="Spearman", sd=sd(rrres$spearman)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="OLS", sd=mean(rrres$se)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="White", sd=mean(rrres$hc0)*sqrt(params$n[i])))#
}#
#
res <- as.data.frame(res)#
res$sd <- as.double(res$sd)#
res$b <- as.double(res$b)#
res$n <- paste("n=",res$n,sep="")
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
	if (na.rm) x <- x[!is.na(x)]#
	return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}
X <- rnorm(100)#
FX <- ecdf(X)#
FX(X)
xrank(X)
rrreg <- function(Y, X) {#
    # FYn <- ecdf(Y)#
    # RY <- FYn(Y)  #
    RY <- xrank(Y)  #
    # FXn <- ecdf(X)#
    # RX <- FXn(X)      #
    RX <- xrank(X)#
    res <- lm(RY ~ RX)#
    rhohat <- coef(summary(res))[2,1]#
    se <- coef(summary(res))[2,2]#
    hc0 <- sqrt(vcovHC(res, type="HC0")[2,2])#
    return(list(rhohat=rhohat,se=se,hc0=hc0))#
}#
#
spearman <- function(Y, X) return(cor(xrank(Y),xrank(X)))#
#
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
    if (na.rm) x <- x[!is.na(x)]#
    return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}#
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
nocores <- detectCores()#
registerDoMC(nocores)#
print(nocores)#
#
n <- c(100,1000)#
nMC <- 1000#
b <- seq(0,5,length=5)#
#
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rrres <- NULL#
    for (mc in 1:nMC) {#
        X <- rnorm(params$n[i])#
        Y <- params$b[i]*X + rnorm(params$n[i])#
        tmp <- rrreg(Y, X)#
        tmp$spearman <- spearman(Y,X)#
        rrres <- rbind(rrres,unlist(tmp))#
    }#
    rrres <- as.data.frame(rrres)#
    rbind(c(n=params$n[i], b=params$b[i], method="Spearman", sd=sd(rrres$spearman)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="OLS", sd=mean(rrres$se)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="White", sd=mean(rrres$hc0)*sqrt(params$n[i])))#
}#
#
res <- as.data.frame(res)#
res$sd <- as.double(res$sd)#
res$b <- as.double(res$b)#
res$n <- paste("n=",res$n,sep="")
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)
library("lattice")
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)
X
xrank(X)
var(xrank(X))
FX
FX(X)
var(FX(X))
sum((xrank(X)-mean(xrank(X)))^2)/100
X
Y <- 2*X+rnorm(100)
FY <- ecdf(Y)
var(FY(Y))
var(xrank(Y))
rrreg <- function(Y, X) {#
    # FYn <- ecdf(Y)#
    # RY <- FYn(Y)  #
    RY <- xrank(Y)  #
    # FXn <- ecdf(X)#
    # RX <- FXn(X)      #
    RX <- xrank(X)#
    res <- lm(RY ~ RX)#
    rhohat <- coef(summary(res))[2,1]#
    se <- coef(summary(res))[2,2]#
    hc0 <- sqrt(vcovHC(res, type="HC0")[2,2])#
    return(list(rhohat=rhohat,se=se,hc0=hc0))#
}#
#
spearman <- function(Y, X) return(cor(xrank(Y),xrank(X)))#
#
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
    if (na.rm) x <- x[!is.na(x)]#
    return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}#
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
nocores <- detectCores()#
registerDoMC(nocores)#
print(nocores)#
#
n <- c(100)#
nMC <- 100#
b <- seq(0,5,length=5)#
#
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rrres <- NULL#
    for (mc in 1:nMC) {#
        X <- rnorm(params$n[i])#
        Y <- params$b[i]*X + rnorm(params$n[i])#
        tmp <- rrreg(Y, X)#
        tmp$spearman <- spearman(Y,X)#
        rrres <- rbind(rrres,unlist(tmp))#
    }#
    rrres <- as.data.frame(rrres)#
    rbind(c(n=params$n[i], b=params$b[i], method="Spearman", sd=sd(rrres$spearman)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="OLS", sd=sqrt(1-mean(rrres$spearman)^2)),#
            c(n=params$n[i], b=params$b[i], method="OLSplim", sd=mean(rrres$se)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="White", sd=mean(rrres$hc0)*sqrt(params$n[i])))#
}#
#
res <- as.data.frame(res)#
res$sd <- as.double(res$sd)#
res$b <- as.double(res$b)#
res$n <- paste("n=",res$n,sep="")
library("lattice")
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)
rrreg <- function(Y, X) {#
    # FYn <- ecdf(Y)#
    # RY <- FYn(Y)  #
    RY <- xrank(Y)  #
    # FXn <- ecdf(X)#
    # RX <- FXn(X)      #
    RX <- xrank(X)#
    res <- lm(RY ~ RX)#
    rhohat <- coef(summary(res))[2,1]#
    se <- coef(summary(res))[2,2]#
    hc0 <- sqrt(vcovHC(res, type="HC0")[2,2])#
    return(list(rhohat=rhohat,se=se,hc0=hc0))#
}#
#
spearman <- function(Y, X) return(cor(xrank(Y),xrank(X)))#
#
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
    if (na.rm) x <- x[!is.na(x)]#
    return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}#
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
nocores <- detectCores()#
registerDoMC(nocores)#
print(nocores)#
#
n <- c(100,1000)#
nMC <- 1000#
b <- seq(0,5,length=5)#
#
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rrres <- NULL#
    for (mc in 1:nMC) {#
        X <- rnorm(params$n[i])#
        Y <- params$b[i]*X + rnorm(params$n[i])#
        tmp <- rrreg(Y, X)#
        tmp$spearman <- spearman(Y,X)#
        rrres <- rbind(rrres,unlist(tmp))#
    }#
    rrres <- as.data.frame(rrres)#
    rbind(c(n=params$n[i], b=params$b[i], method="Spearman", sd=sd(rrres$spearman)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="OLS", sd=sqrt(1-mean(rrres$spearman)^2)),#
            c(n=params$n[i], b=params$b[i], method="OLSplim", sd=mean(rrres$se)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="White", sd=mean(rrres$hc0)*sqrt(params$n[i])))#
}#
#
res <- as.data.frame(res)#
res$sd <- as.double(res$sd)#
res$b <- as.double(res$b)#
res$n <- paste("n=",res$n,sep="")#
#
save.image("workspace.RData")#
#
library("lattice")#
pdf(file="spearman_vs_ols.pdf",width=12,height=8)#
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)#
dev.off()
load("/Users/uctpdwi/workspace.RData")
library("lattice")
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)
pdf(file="spearman_vs_ols.pdf",width=12,height=8)#
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)#
dev.off()
pdf(file="spearman_vs_ols.pdf",width=6,height=8)#
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)#
dev.off()
pdf(file="spearman_vs_ols.pdf",width=7,height=8)#
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)#
dev.off()
rrreg <- function(Y, X) {#
    # FYn <- ecdf(Y)#
    # RY <- FYn(Y)  #
    RY <- xrank(Y)  #
    # FXn <- ecdf(X)#
    # RX <- FXn(X)      #
    RX <- xrank(X)#
    res <- lm(RY ~ RX)#
    rhohat <- coef(summary(res))[2,1]#
    se <- coef(summary(res))[2,2]#
    hc0 <- sqrt(vcovHC(res, type="HC0")[2,2])#
    return(list(rhohat=rhohat,se=se,hc0=hc0))#
}#
#
spearman <- function(Y, X) return(cor(xrank(Y),xrank(X)))#
#
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
    if (na.rm) x <- x[!is.na(x)]#
    return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}#
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
nocores <- detectCores()#
registerDoMC(nocores)#
print(nocores)#
#
n <- c(100,1000)#
nMC <- 1000#
b <- -seq(0,5,length=5)#
#
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rrres <- NULL#
    for (mc in 1:nMC) {#
        X <- rnorm(params$n[i])#
        Y <- params$b[i]*X + rnorm(params$n[i])#
        tmp <- rrreg(Y, X)#
        tmp$spearman <- spearman(Y,X)#
        rrres <- rbind(rrres,unlist(tmp))#
    }#
    rrres <- as.data.frame(rrres)#
    rbind(c(n=params$n[i], b=params$b[i], method="Spearman", sd=sd(rrres$spearman)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="OLS", sd=sqrt(1-mean(rrres$spearman)^2)),#
            c(n=params$n[i], b=params$b[i], method="OLSplim", sd=mean(rrres$se)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="White", sd=mean(rrres$hc0)*sqrt(params$n[i])))#
}#
#
res <- as.data.frame(res)#
res$sd <- as.double(res$sd)#
res$b <- as.double(res$b)#
res$n <- paste("n=",res$n,sep="")#
#
save.image("workspace.RData")#
#
library("lattice")#
pdf(file="spearman_vs_ols.pdf",width=12,height=8)#
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)#
dev.off()
rrreg <- function(Y, X) {#
    # FYn <- ecdf(Y)#
    # RY <- FYn(Y)  #
    RY <- xrank(Y)  #
    # FXn <- ecdf(X)#
    # RX <- FXn(X)      #
    RX <- xrank(X)#
    res <- lm(RY ~ RX)#
    rhohat <- coef(summary(res))[2,1]#
    se <- coef(summary(res))[2,2]#
    hc0 <- sqrt(vcovHC(res, type="HC0")[2,2])#
    return(list(rhohat=rhohat,se=se,hc0=hc0))#
}#
#
spearman <- function(Y, X) return(cor(xrank(Y),xrank(X)))#
#
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
    if (na.rm) x <- x[!is.na(x)]#
    return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}#
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
nocores <- detectCores()#
registerDoMC(nocores)#
print(nocores)#
#
n <- c(100,1000)#
nMC <- 10000#
b <- -seq(0,5,length=5)#
#
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rrres <- NULL#
    for (mc in 1:nMC) {#
        X <- rnorm(params$n[i])#
        Y <- params$b[i]*X + rnorm(params$n[i])#
        tmp <- rrreg(Y, X)#
        tmp$spearman <- spearman(Y,X)#
        rrres <- rbind(rrres,unlist(tmp))#
    }#
    rrres <- as.data.frame(rrres)#
    rbind(c(n=params$n[i], b=params$b[i], method="Spearman", sd=sd(rrres$spearman)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="OLS", sd=sqrt(1-mean(rrres$spearman)^2)),#
            c(n=params$n[i], b=params$b[i], method="OLSplim", sd=mean(rrres$se)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="White", sd=mean(rrres$hc0)*sqrt(params$n[i])))#
}#
#
res <- as.data.frame(res)#
res$sd <- as.double(res$sd)#
res$b <- as.double(res$b)#
res$n <- paste("n=",res$n,sep="")#
#
save.image("workspace.RData")#
#
library("lattice")#
pdf(file="spearman_vs_ols.pdf",width=12,height=8)#
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)#
dev.off()
exp(rnorm(100))
rrreg <- function(Y, X) {#
    # FYn <- ecdf(Y)#
    # RY <- FYn(Y)  #
    RY <- xrank(Y)  #
    # FXn <- ecdf(X)#
    # RX <- FXn(X)      #
    RX <- xrank(X)#
    res <- lm(RY ~ RX)#
    rhohat <- coef(summary(res))[2,1]#
    se <- coef(summary(res))[2,2]#
    hc0 <- sqrt(vcovHC(res, type="HC0")[2,2])#
    return(list(rhohat=rhohat,se=se,hc0=hc0))#
}#
#
spearman <- function(Y, X) return(cor(xrank(Y),xrank(X)))#
#
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
    if (na.rm) x <- x[!is.na(x)]#
    return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}#
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
nocores <- detectCores()#
registerDoMC(nocores)#
print(nocores)#
#
n <- c(100,1000)#
nMC <- 1000#
b <- -seq(0,5,length=5)#
#
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rrres <- NULL#
    for (mc in 1:nMC) {#
        X <- exp(rnorm(params$n[i]))#
        Y <- params$b[i]*X + rnorm(params$n[i])#
        tmp <- rrreg(Y, X)#
        tmp$spearman <- spearman(Y,X)#
        rrres <- rbind(rrres,unlist(tmp))#
    }#
    rrres <- as.data.frame(rrres)#
    rbind(c(n=params$n[i], b=params$b[i], method="Spearman", sd=sd(rrres$spearman)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="OLS", sd=sqrt(1-mean(rrres$spearman)^2)),#
            c(n=params$n[i], b=params$b[i], method="OLSplim", sd=mean(rrres$se)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="White", sd=mean(rrres$hc0)*sqrt(params$n[i])))#
}#
#
res <- as.data.frame(res)#
res$sd <- as.double(res$sd)#
res$b <- as.double(res$b)#
res$n <- paste("n=",res$n,sep="")#
#
save.image("workspace.RData")#
#
library("lattice")#
pdf(file="spearman_vs_ols.pdf",width=12,height=8)#
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)#
dev.off()
rrreg <- function(Y, X) {#
    # FYn <- ecdf(Y)#
    # RY <- FYn(Y)  #
    RY <- xrank(Y)  #
    # FXn <- ecdf(X)#
    # RX <- FXn(X)      #
    RX <- xrank(X)#
    res <- lm(RY ~ RX)#
    rhohat <- coef(summary(res))[2,1]#
    se <- coef(summary(res))[2,2]#
    hc0 <- sqrt(vcovHC(res, type="HC0")[2,2])#
    return(list(rhohat=rhohat,se=se,hc0=hc0))#
}#
#
spearman <- function(Y, X) return(cor(xrank(Y),xrank(X)))#
#
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
    if (na.rm) x <- x[!is.na(x)]#
    return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}#
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
nocores <- detectCores()#
registerDoMC(nocores)#
print(nocores)#
#
n <- c(100,1000)#
nMC <- 1000#
b <- -seq(0,5,length=5)#
#
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rrres <- NULL#
    for (mc in 1:nMC) {#
        X <- exp(rnorm(params$n[i]))#
        Y <- exp(params$b[i]*X + rnorm(params$n[i]))#
        tmp <- rrreg(Y, X)#
        tmp$spearman <- spearman(Y,X)#
        rrres <- rbind(rrres,unlist(tmp))#
    }#
    rrres <- as.data.frame(rrres)#
    rbind(c(n=params$n[i], b=params$b[i], method="Spearman", sd=sd(rrres$spearman)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="OLS", sd=sqrt(1-mean(rrres$spearman)^2)),#
            c(n=params$n[i], b=params$b[i], method="OLSplim", sd=mean(rrres$se)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="White", sd=mean(rrres$hc0)*sqrt(params$n[i])))#
}#
#
res <- as.data.frame(res)#
res$sd <- as.double(res$sd)#
res$b <- as.double(res$b)#
res$n <- paste("n=",res$n,sep="")#
#
save.image("workspace.RData")#
#
library("lattice")#
pdf(file="spearman_vs_ols.pdf",width=12,height=8)#
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)#
dev.off()
?rbinom
rbinom(100,1,0.1)
rbinom(100,1,0.5)
rbinom(100,2,0.5)
rrreg <- function(Y, X) {#
    # FYn <- ecdf(Y)#
    # RY <- FYn(Y)  #
    RY <- xrank(Y)  #
    # FXn <- ecdf(X)#
    # RX <- FXn(X)      #
    RX <- xrank(X)#
    res <- lm(RY ~ RX)#
    rhohat <- coef(summary(res))[2,1]#
    se <- coef(summary(res))[2,2]#
    hc0 <- sqrt(vcovHC(res, type="HC0")[2,2])#
    return(list(rhohat=rhohat,se=se,hc0=hc0))#
}#
#
spearman <- function(Y, X) return(cor(xrank(Y),xrank(X)))#
#
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
    if (na.rm) x <- x[!is.na(x)]#
    return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}#
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
nocores <- detectCores()#
registerDoMC(nocores)#
print(nocores)#
#
n <- c(100,1000)#
nMC <- 1000#
dgp <- 1#
if (dgp==1) b <- seq(0,5,length=5)#
if (dgp==2) b <- seq(0,1,length=5)#
#
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rrres <- NULL#
    for (mc in 1:nMC) {#
        if (dgp==1) {#
            X <- rnorm(params$n[i])#
            Y <- params$b[i]*X + rnorm(params$n[i])#
        }#
        if (dgp==2) {#
            D <- rbinom(params$n[i], 1, params$b[i])#
            X <- runif(params$n[i])#
            Y <- D*X + (1-D)*runif(params$n[i])#
        }#
        tmp <- rrreg(Y, X)#
        tmp$spearman <- spearman(Y,X)#
        rrres <- rbind(rrres,unlist(tmp))#
    }#
    rrres <- as.data.frame(rrres)#
    rbind(c(n=params$n[i], b=params$b[i], method="Spearman", sd=sd(rrres$spearman)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="OLS", sd=sqrt(1-mean(rrres$spearman)^2)),#
            c(n=params$n[i], b=params$b[i], method="OLSplim", sd=mean(rrres$se)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="White", sd=mean(rrres$hc0)*sqrt(params$n[i])))#
}#
#
res <- as.data.frame(res)#
res$sd <- as.double(res$sd)#
res$b <- as.double(res$b)#
res$n <- paste("n=",res$n,sep="")#
#
save.image("workspace.RData")#
#
library("lattice")#
pdf(file="spearman_vs_ols.pdf",width=12,height=8)#
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)#
dev.off()
rrreg <- function(Y, X) {#
    # FYn <- ecdf(Y)#
    # RY <- FYn(Y)  #
    RY <- xrank(Y)  #
    # FXn <- ecdf(X)#
    # RX <- FXn(X)      #
    RX <- xrank(X)#
    res <- lm(RY ~ RX)#
    rhohat <- coef(summary(res))[2,1]#
    se <- coef(summary(res))[2,2]#
    hc0 <- sqrt(vcovHC(res, type="HC0")[2,2])#
    return(list(rhohat=rhohat,se=se,hc0=hc0))#
}#
#
spearman <- function(Y, X) return(cor(xrank(Y),xrank(X)))#
#
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
    if (na.rm) x <- x[!is.na(x)]#
    return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}#
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
nocores <- detectCores()#
registerDoMC(nocores)#
print(nocores)#
#
n <- c(100,1000)#
nMC <- 1000#
dgp <- 2#
if (dgp==1) b <- seq(0,5,length=5)#
if (dgp==2) b <- seq(0,1,length=5)#
#
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rrres <- NULL#
    for (mc in 1:nMC) {#
        if (dgp==1) {#
            X <- rnorm(params$n[i])#
            Y <- params$b[i]*X + rnorm(params$n[i])#
        }#
        if (dgp==2) {#
            D <- rbinom(params$n[i], 1, params$b[i])#
            X <- runif(params$n[i])#
            Y <- D*X + (1-D)*runif(params$n[i])#
        }#
        tmp <- rrreg(Y, X)#
        tmp$spearman <- spearman(Y,X)#
        rrres <- rbind(rrres,unlist(tmp))#
    }#
    rrres <- as.data.frame(rrres)#
    rbind(c(n=params$n[i], b=params$b[i], method="Spearman", sd=sd(rrres$spearman)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="OLS", sd=sqrt(1-mean(rrres$spearman)^2)),#
            c(n=params$n[i], b=params$b[i], method="OLSplim", sd=mean(rrres$se)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="White", sd=mean(rrres$hc0)*sqrt(params$n[i])))#
}#
#
res <- as.data.frame(res)#
res$sd <- as.double(res$sd)#
res$b <- as.double(res$b)#
res$n <- paste("n=",res$n,sep="")#
#
save.image("workspace.RData")#
#
library("lattice")#
pdf(file="spearman_vs_ols.pdf",width=12,height=8)#
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)#
dev.off()
rrreg <- function(Y, X) {#
    # FYn <- ecdf(Y)#
    # RY <- FYn(Y)  #
    RY <- xrank(Y)  #
    # FXn <- ecdf(X)#
    # RX <- FXn(X)      #
    RX <- xrank(X)#
    res <- lm(RY ~ RX)#
    rhohat <- coef(summary(res))[2,1]#
    se <- coef(summary(res))[2,2]#
    hc0 <- sqrt(vcovHC(res, type="HC0")[2,2])#
    return(list(rhohat=rhohat,se=se,hc0=hc0))#
}#
#
spearman <- function(Y, X) return(cor(xrank(Y),xrank(X)))#
#
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
    if (na.rm) x <- x[!is.na(x)]#
    return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}#
#
setwd("/home/dwilhelm/rrreg/sim")#
#
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
require(copula)#
require(mistr)#
nocores <- detectCores()#
registerDoMC(nocores)#
print(nocores)#
#
n <- c(100,1000)#
nMC <- 1000#
dgp <- 3#
if (dgp==1) b <- seq(0,5,length=5)#
if (dgp==2) b <- seq(0,1,length=5)#
if (dgp==3) b <- seq(-1,1,length=5)#
#
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rrres <- NULL#
    for (mc in 1:nMC) {#
        if (dgp==1) {#
            X <- rnorm(params$n[i])#
            Y <- params$b[i]*X + rnorm(params$n[i])#
        }#
        if (dgp==2) {#
            D <- rbinom(params$n[i], 1, params$b[i])#
            X <- runif(params$n[i])#
            Y <- D*X + (1-D)*runif(params$n[i])#
        }#
        if (dgp==3) {#
            stopifnot(abs(rho)<=1/3)#
            cop <- fgmCopula(params$b[i])#
            dat <- rCopula(params$n[i], cop)#
            Y <- dat[,1]#
            X <- dat[,2]#
        }#
        tmp <- rrreg(Y, X)#
        tmp$spearman <- spearman(Y,X)#
        rrres <- rbind(rrres,unlist(tmp))#
    }#
    rrres <- as.data.frame(rrres)#
    rbind(c(n=params$n[i], b=params$b[i], method="Spearman", sd=sd(rrres$spearman)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="OLS", sd=sqrt(1-mean(rrres$spearman)^2)),#
            c(n=params$n[i], b=params$b[i], method="OLSplim", sd=mean(rrres$se)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="White", sd=mean(rrres$hc0)*sqrt(params$n[i])))#
}#
#
res <- as.data.frame(res)#
res$sd <- as.double(res$sd)#
res$b <- as.double(res$b)#
res$n <- paste("n=",res$n,sep="")#
#
save.image("workspace.RData")#
#
library("lattice")#
pdf(file="spearman_vs_ols.pdf",width=12,height=8)#
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)#
dev.off()
i
i<-1
cop <- fgmCopula(params$b[i])
dat <- rCopula(params$n[i], cop)
Y <- dat[,1]
X <- dat[,2]
Y
X
rrreg <- function(Y, X) {#
    # FYn <- ecdf(Y)#
    # RY <- FYn(Y)  #
    RY <- xrank(Y)  #
    # FXn <- ecdf(X)#
    # RX <- FXn(X)      #
    RX <- xrank(X)#
    res <- lm(RY ~ RX)#
    rhohat <- coef(summary(res))[2,1]#
    se <- coef(summary(res))[2,2]#
    hc0 <- sqrt(vcovHC(res, type="HC0")[2,2])#
    return(list(rhohat=rhohat,se=se,hc0=hc0))#
}#
#
spearman <- function(Y, X) return(cor(xrank(Y),xrank(X)))#
#
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
    if (na.rm) x <- x[!is.na(x)]#
    return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}#
#
setwd("/home/dwilhelm/rrreg/sim")#
#
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
require(copula)#
require(mistr)#
nocores <- detectCores()#
registerDoMC(nocores)#
print(nocores)#
#
n <- c(100,1000)#
nMC <- 1000#
dgp <- 3#
if (dgp==1) b <- seq(0,5,length=5)#
if (dgp==2) b <- seq(0,1,length=5)#
if (dgp==3) b <- seq(-1,1,length=5)#
#
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rrres <- NULL#
    for (mc in 1:nMC) {#
        if (dgp==1) {#
            X <- rnorm(params$n[i])#
            Y <- params$b[i]*X + rnorm(params$n[i])#
        }#
        if (dgp==2) {#
            D <- rbinom(params$n[i], 1, params$b[i])#
            X <- runif(params$n[i])#
            Y <- D*X + (1-D)*runif(params$n[i])#
        }#
        if (dgp==3) {#
            cop <- fgmCopula(params$b[i])#
            dat <- rCopula(params$n[i], cop)#
            Y <- dat[,1]#
            X <- dat[,2]#
        }#
        tmp <- rrreg(Y, X)#
        tmp$spearman <- spearman(Y,X)#
        rrres <- rbind(rrres,unlist(tmp))#
    }#
    rrres <- as.data.frame(rrres)#
    rbind(c(n=params$n[i], b=params$b[i], method="Spearman", sd=sd(rrres$spearman)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="OLS", sd=sqrt(1-mean(rrres$spearman)^2)),#
            c(n=params$n[i], b=params$b[i], method="OLSplim", sd=mean(rrres$se)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="White", sd=mean(rrres$hc0)*sqrt(params$n[i])))#
}#
#
res <- as.data.frame(res)#
res$sd <- as.double(res$sd)#
res$b <- as.double(res$b)#
res$n <- paste("n=",res$n,sep="")#
#
save.image("workspace.RData")#
#
library("lattice")#
pdf(file="spearman_vs_ols.pdf",width=12,height=8)#
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)#
dev.off()
rrreg <- function(Y, X) {#
    # FYn <- ecdf(Y)#
    # RY <- FYn(Y)  #
    RY <- xrank(Y)  #
    # FXn <- ecdf(X)#
    # RX <- FXn(X)      #
    RX <- xrank(X)#
    res <- lm(RY ~ RX)#
    rhohat <- coef(summary(res))[2,1]#
    se <- coef(summary(res))[2,2]#
    hc0 <- sqrt(vcovHC(res, type="HC0")[2,2])#
    return(list(rhohat=rhohat,se=se,hc0=hc0))#
}#
#
spearman <- function(Y, X) return(cor(xrank(Y),xrank(X)))#
#
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
    if (na.rm) x <- x[!is.na(x)]#
    return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}#
#
# setwd("/home/dwilhelm/rrreg/sim")#
#
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
require(copula)#
require(mistr)#
nocores <- detectCores()-1#
registerDoMC(nocores)#
print(nocores)#
#
n <- c(100,1000)#
nMC <- 1000#
dgp <- 4#
if (dgp==1) b <- seq(0,5,length=5)#
if (dgp==2) b <- seq(0,1,length=5)#
if (dgp==3) b <- seq(0,1,length=5)#
if (dgp==4) b <- seq(0,1,length=5)#
#
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rrres <- NULL#
    for (mc in 1:nMC) {#
        if (dgp==1) {#
            X <- rnorm(params$n[i])#
            Y <- params$b[i]*X + rnorm(params$n[i])#
        }#
        if (dgp==2) {#
            D <- rbinom(params$n[i], 1, params$b[i])#
            X <- runif(params$n[i])#
            Y <- D*X + (1-D)*runif(params$n[i])#
        }#
        if (dgp==3) {#
            cop <- fgmCopula(params$b[i])#
            dat <- rCopula(params$n[i], cop)#
            Y <- dat[,1]#
            X <- dat[,2]#
        }#
        if (dgp==4) {#
            if (params$b[i]==0) { #
                a <- 0; d <- 0.1#
            } else {#
                a <- 4*params$b[i] / (3+params$b[i])#
                d <- a#
            }#
            cop <- moCopula(c(a,d))#
        }#
        tmp <- rrreg(Y, X)#
        tmp$spearman <- spearman(Y,X)#
        rrres <- rbind(rrres,unlist(tmp))#
    }#
    rrres <- as.data.frame(rrres)#
    rbind(c(n=params$n[i], b=params$b[i], method="Spearman", sd=sd(rrres$spearman)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="OLS", sd=sqrt(1-mean(rrres$spearman)^2)),#
            c(n=params$n[i], b=params$b[i], method="OLSplim", sd=mean(rrres$se)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="White", sd=mean(rrres$hc0)*sqrt(params$n[i])))#
}#
#
res <- as.data.frame(res)#
res$sd <- as.double(res$sd)#
res$b <- as.double(res$b)#
res$n <- paste("n=",res$n,sep="")#
#
save.image("workspace.RData")#
#
library("lattice")#
pdf(file="spearman_vs_ols.pdf",width=12,height=8)#
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)#
dev.off()
X <- dat[,2]a
rrreg <- function(Y, X) {#
    # FYn <- ecdf(Y)#
    # RY <- FYn(Y)  #
    RY <- xrank(Y)  #
    # FXn <- ecdf(X)#
    # RX <- FXn(X)      #
    RX <- xrank(X)#
    res <- lm(RY ~ RX)#
    rhohat <- coef(summary(res))[2,1]#
    se <- coef(summary(res))[2,2]#
    hc0 <- sqrt(vcovHC(res, type="HC0")[2,2])#
    return(list(rhohat=rhohat,se=se,hc0=hc0))#
}#
#
spearman <- function(Y, X) return(cor(xrank(Y),xrank(X)))#
#
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
    if (na.rm) x <- x[!is.na(x)]#
    return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}#
#
# setwd("/home/dwilhelm/rrreg/sim")#
#
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
require(copula)#
require(mistr)#
nocores <- detectCores()-1#
registerDoMC(nocores)#
print(nocores)#
#
n <- c(100,1000)#
nMC <- 1000#
dgp <- 4#
if (dgp==1) b <- seq(0,5,length=5)#
if (dgp==2) b <- seq(0,1,length=5)#
if (dgp==3) b <- seq(0,1,length=5)#
if (dgp==4) b <- seq(0,1,length=5)#
#
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rrres <- NULL#
    for (mc in 1:nMC) {#
        if (dgp==1) {#
            X <- rnorm(params$n[i])#
            Y <- params$b[i]*X + rnorm(params$n[i])#
        }#
        if (dgp==2) {#
            D <- rbinom(params$n[i], 1, params$b[i])#
            X <- runif(params$n[i])#
            Y <- D*X + (1-D)*runif(params$n[i])#
        }#
        if (dgp==3) {#
            cop <- fgmCopula(params$b[i])#
            dat <- rCopula(params$n[i], cop)#
            Y <- dat[,1]#
            X <- dat[,2]#
        }#
        if (dgp==4) {#
            if (params$b[i]==0) { #
                a <- 0; d <- 0.1#
            } else {#
                a <- 4*params$b[i] / (3+params$b[i])#
                d <- a#
            }#
            cop <- moCopula(c(a,d))#
            dat <- rCopula(params$n[i], cop)#
            Y <- dat[,1]#
            X <- dat[,2]#
        }#
        tmp <- rrreg(Y, X)#
        tmp$spearman <- spearman(Y,X)#
        rrres <- rbind(rrres,unlist(tmp))#
    }#
    rrres <- as.data.frame(rrres)#
    rbind(c(n=params$n[i], b=params$b[i], method="Spearman", sd=sd(rrres$spearman)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="OLS", sd=sqrt(1-mean(rrres$spearman)^2)),#
            c(n=params$n[i], b=params$b[i], method="OLSplim", sd=mean(rrres$se)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="White", sd=mean(rrres$hc0)*sqrt(params$n[i])))#
}#
#
res <- as.data.frame(res)#
res$sd <- as.double(res$sd)#
res$b <- as.double(res$b)#
res$n <- paste("n=",res$n,sep="")#
#
save.image("workspace.RData")#
#
library("lattice")#
pdf(file="spearman_vs_ols.pdf",width=12,height=8)#
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)#
dev.off()
rrreg <- function(Y, X) {#
    # FYn <- ecdf(Y)#
    # RY <- FYn(Y)  #
    RY <- xrank(Y)  #
    # FXn <- ecdf(X)#
    # RX <- FXn(X)      #
    RX <- xrank(X)#
    res <- lm(RY ~ RX)#
    rhohat <- coef(summary(res))[2,1]#
    se <- coef(summary(res))[2,2]#
    hc0 <- sqrt(vcovHC(res, type="HC0")[2,2])#
    return(list(rhohat=rhohat,se=se,hc0=hc0))#
}#
#
spearman <- function(Y, X) return(cor(xrank(Y),xrank(X)))#
#
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
    if (na.rm) x <- x[!is.na(x)]#
    return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}#
#
# setwd("/home/dwilhelm/rrreg/sim")#
#
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
require(copula)#
require(mistr)#
nocores <- detectCores()-1#
registerDoMC(nocores)#
print(nocores)#
#
n <- c(100,1000)#
nMC <- 1000#
dgp <- 4#
if (dgp==1) b <- seq(0,5,length=5)#
if (dgp==2) b <- seq(0,1,length=5)#
if (dgp==3) b <- seq(0,1,length=5)#
if (dgp==4) b <- seq(0,1,length=5)#
#
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rrres <- NULL#
    for (mc in 1:nMC) {#
        if (dgp==1) {#
            X <- rnorm(params$n[i])#
            Y <- params$b[i]*X + rnorm(params$n[i])#
        }#
        if (dgp==2) {#
            D <- rbinom(params$n[i], 1, params$b[i])#
            X <- runif(params$n[i])#
            Y <- D*X + (1-D)*runif(params$n[i])#
        }#
        if (dgp==3) {#
            cop <- fgmCopula(params$b[i])#
            dat <- rCopula(params$n[i], cop)#
            Y <- dat[,1]#
            X <- dat[,2]#
        }#
        if (dgp==4) {#
            a <- 1#
            d <- 2*params$b[i]/(3-params$b[i])#
            cop <- moCopula(c(a,d))#
            dat <- rCopula(params$n[i], cop)#
            Y <- dat[,1]#
            X <- dat[,2]#
        }#
        tmp <- rrreg(Y, X)#
        tmp$spearman <- spearman(Y,X)#
        rrres <- rbind(rrres,unlist(tmp))#
    }#
    rrres <- as.data.frame(rrres)#
    rbind(c(n=params$n[i], b=params$b[i], method="Spearman", sd=sd(rrres$spearman)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="OLS", sd=sqrt(1-mean(rrres$spearman)^2)),#
            c(n=params$n[i], b=params$b[i], method="OLSplim", sd=mean(rrres$se)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="White", sd=mean(rrres$hc0)*sqrt(params$n[i])))#
}#
#
res <- as.data.frame(res)#
res$sd <- as.double(res$sd)#
res$b <- as.double(res$b)#
res$n <- paste("n=",res$n,sep="")#
#
save.image("workspace.RData")#
#
library("lattice")#
pdf(file="spearman_vs_ols.pdf",width=12,height=8)#
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)#
dev.off()
rrreg <- function(Y, X) {#
    # FYn <- ecdf(Y)#
    # RY <- FYn(Y)  #
    RY <- xrank(Y)  #
    # FXn <- ecdf(X)#
    # RX <- FXn(X)      #
    RX <- xrank(X)#
    res <- lm(RY ~ RX)#
    rhohat <- coef(summary(res))[2,1]#
    se <- coef(summary(res))[2,2]#
    hc0 <- sqrt(vcovHC(res, type="HC0")[2,2])#
    return(list(rhohat=rhohat,se=se,hc0=hc0))#
}#
#
spearman <- function(Y, X) return(cor(xrank(Y),xrank(X)))#
#
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
    if (na.rm) x <- x[!is.na(x)]#
    return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}#
#
# setwd("/home/dwilhelm/rrreg/sim")#
#
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
require(copula)#
require(mistr)#
nocores <- detectCores()-1#
registerDoMC(nocores)#
print(nocores)#
#
n <- c(100,1000)#
nMC <- 1000#
dgp <- 2#
if (dgp==1) b <- seq(0,5,length=5)#
if (dgp==2) b <- seq(0,1,length=5)#
if (dgp==3) b <- seq(0,1,length=5)#
if (dgp==4) b <- seq(0,1,length=5)#
#
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rrres <- NULL#
    for (mc in 1:nMC) {#
        if (dgp==1) {#
            X <- rnorm(params$n[i])#
            Y <- params$b[i]*X + rnorm(params$n[i])#
        }#
        if (dgp==2) {#
            D <- rbinom(params$n[i], 1, params$b[i])#
            X <- runif(params$n[i])#
            Y <- -D*X + (1-D)*runif(params$n[i])#
        }#
        if (dgp==3) {#
            cop <- fgmCopula(params$b[i])#
            dat <- rCopula(params$n[i], cop)#
            Y <- dat[,1]#
            X <- dat[,2]#
        }#
        if (dgp==4) {#
            a <- 1#
            d <- 2*params$b[i]/(3-params$b[i])#
            cop <- moCopula(c(a,d))#
            dat <- rCopula(params$n[i], cop)#
            Y <- dat[,1]#
            X <- dat[,2]#
        }#
        tmp <- rrreg(Y, X)#
        tmp$spearman <- spearman(Y,X)#
        rrres <- rbind(rrres,unlist(tmp))#
    }#
    rrres <- as.data.frame(rrres)#
    rbind(c(n=params$n[i], b=params$b[i], method="Spearman", sd=sd(rrres$spearman)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="OLS", sd=sqrt(1-mean(rrres$spearman)^2)),#
            c(n=params$n[i], b=params$b[i], method="OLSplim", sd=mean(rrres$se)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="White", sd=mean(rrres$hc0)*sqrt(params$n[i])))#
}#
#
res <- as.data.frame(res)#
res$sd <- as.double(res$sd)#
res$b <- as.double(res$b)#
res$n <- paste("n=",res$n,sep="")#
#
save.image("workspace.RData")#
#
library("lattice")#
pdf(file="spearman_vs_ols.pdf",width=12,height=8)#
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)#
dev.off()
rrreg <- function(Y, X) {#
    # FYn <- ecdf(Y)#
    # RY <- FYn(Y)  #
    RY <- xrank(Y)  #
    # FXn <- ecdf(X)#
    # RX <- FXn(X)      #
    RX <- xrank(X)#
    res <- lm(RY ~ RX)#
    rhohat <- coef(summary(res))[2,1]#
    se <- coef(summary(res))[2,2]#
    hc0 <- sqrt(vcovHC(res, type="HC0")[2,2])#
    return(list(rhohat=rhohat,se=se,hc0=hc0))#
}#
#
spearman <- function(Y, X) return(cor(xrank(Y),xrank(X)))#
#
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
    if (na.rm) x <- x[!is.na(x)]#
    return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}#
#
# setwd("/home/dwilhelm/rrreg/sim")#
#
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
require(copula)#
require(mistr)#
nocores <- detectCores()-1#
registerDoMC(nocores)#
print(nocores)#
#
n <- c(100,1000)#
nMC <- 10000#
dgp <- 2#
if (dgp==1) b <- seq(0,5,length=5)#
if (dgp==2) b <- seq(0,1,length=5)#
if (dgp==3) b <- seq(0,1,length=5)#
if (dgp==4) b <- seq(0,1,length=5)#
#
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rrres <- NULL#
    for (mc in 1:nMC) {#
        if (dgp==1) {#
            X <- rnorm(params$n[i])#
            Y <- params$b[i]*X + rnorm(params$n[i])#
        }#
        if (dgp==2) {#
            D <- rbinom(params$n[i], 1, params$b[i])#
            X <- runif(params$n[i])#
            Y <- -D*X + (1-D)*runif(params$n[i])#
        }#
        if (dgp==3) {#
            cop <- fgmCopula(params$b[i])#
            dat <- rCopula(params$n[i], cop)#
            Y <- dat[,1]#
            X <- dat[,2]#
        }#
        if (dgp==4) {#
            a <- 1#
            d <- 2*params$b[i]/(3-params$b[i])#
            cop <- moCopula(c(a,d))#
            dat <- rCopula(params$n[i], cop)#
            Y <- dat[,1]#
            X <- dat[,2]#
        }#
        tmp <- rrreg(Y, X)#
        tmp$spearman <- spearman(Y,X)#
        rrres <- rbind(rrres,unlist(tmp))#
    }#
    rrres <- as.data.frame(rrres)#
    rbind(c(n=params$n[i], b=params$b[i], method="Spearman", sd=sd(rrres$spearman)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="OLS", sd=sqrt(1-mean(rrres$spearman)^2)),#
            c(n=params$n[i], b=params$b[i], method="OLSplim", sd=mean(rrres$se)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="White", sd=mean(rrres$hc0)*sqrt(params$n[i])))#
}#
#
res <- as.data.frame(res)#
res$sd <- as.double(res$sd)#
res$b <- as.double(res$b)#
res$n <- paste("n=",res$n,sep="")#
#
save.image("workspace.RData")#
#
library("lattice")#
pdf(file="spearman_vs_ols.pdf",width=12,height=8)#
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)#
dev.off()
rreg <- function(Y, X) {#
    FXn <- ecdf(X)#
    RX <- FXn(X)        #
    # RX <- xrank(X)#
    res <- lm(Y ~ RX)#
    rhohat <- coef(summary(res))[2,1]#
    se <- coef(summary(res))[2,2]#
    hc0 <- sqrt(vcovHC(res, type="HC0")[2,2])#
    return(list(rhohat=rhohat,se=se,hc0=hc0))#
}#
#
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
    if (na.rm) x <- x[!is.na(x)]#
    return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}#
#
# setwd("/home/dwilhelm/rrreg/sim")#
#
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
# require(copula)#
# require(mistr)#
nocores <- detectCores()-1#
registerDoMC(nocores)#
print(nocores)#
#
n <- c(100,1000)#
nMC <- 100#
dgp <- 1#
if (dgp==1) b <- seq(0,5,length=5)#
#
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rres <- NULL#
    for (mc in 1:nMC) {#
        if (dgp==1) {#
            X <- rnorm(params$n[i])#
            Y <- params$b[i]*pnorm(X) + rnorm(params$n[i])#
        }#
        tmp <- rreg(Y, X)#
        rres <- rbind(rres,unlist(tmp))#
    }#
    rres <- as.data.frame(rres)#
    rbind(c(n=params$n[i], b=params$b[i], method="emp", sd=sd(rres$spearman)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="OLS", sd=mean(rres$se)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="White", sd=mean(rres$hc0)*sqrt(params$n[i])))#
}#
#
res <- as.data.frame(res)#
res$sd <- as.double(res$sd)#
res$b <- as.double(res$b)#
res$n <- paste("n=",res$n,sep="")#
#
save.image("workspace.RData")#
#
library("lattice")#
pdf(file="ols_on_rank.pdf",width=12,height=8)#
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)#
dev.off()
rreg <- function(Y, X) {#
    FXn <- ecdf(X)#
    RX <- FXn(X)        #
    # RX <- xrank(X)#
    res <- lm(Y ~ RX)#
    rhohat <- coef(summary(res))[2,1]#
    se <- coef(summary(res))[2,2]#
    hc0 <- sqrt(vcovHC(res, type="HC0")[2,2])#
    return(list(rhohat=rhohat,se=se,hc0=hc0))#
}#
#
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
    if (na.rm) x <- x[!is.na(x)]#
    return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}#
#
# setwd("/home/dwilhelm/rrreg/sim")#
#
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
# require(copula)#
# require(mistr)#
nocores <- detectCores()-1#
registerDoMC(nocores)#
print(nocores)#
#
n <- c(100,1000)#
nMC <- 1000#
dgp <- 1#
if (dgp==1) b <- seq(0,5,length=5)#
#
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rres <- NULL#
    for (mc in 1:nMC) {#
        if (dgp==1) {#
            X <- rnorm(params$n[i])#
            Y <- params$b[i]*pnorm(X) + rnorm(params$n[i])#
        }#
        tmp <- rreg(Y, X)#
        rres <- rbind(rres,unlist(tmp))#
    }#
    rres <- as.data.frame(rres)#
    rbind(c(n=params$n[i], b=params$b[i], method="emp", sd=sd(rres$spearman)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="OLS", sd=mean(rres$se)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="White", sd=mean(rres$hc0)*sqrt(params$n[i])))#
}#
#
res <- as.data.frame(res)#
res$sd <- as.double(res$sd)#
res$b <- as.double(res$b)#
res$n <- paste("n=",res$n,sep="")#
#
save.image("workspace.RData")#
#
library("lattice")#
pdf(file="ols_on_rank.pdf",width=12,height=8)#
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)#
dev.off()
res
rreg <- function(Y, X) {#
    FXn <- ecdf(X)#
    RX <- FXn(X)        #
    # RX <- xrank(X)#
    res <- lm(Y ~ RX)#
    rhohat <- coef(summary(res))[2,1]#
    se <- coef(summary(res))[2,2]#
    hc0 <- sqrt(vcovHC(res, type="HC0")[2,2])#
    return(list(rhohat=rhohat,se=se,hc0=hc0))#
}#
#
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
    if (na.rm) x <- x[!is.na(x)]#
    return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}#
#
# setwd("/home/dwilhelm/rrreg/sim")#
#
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
# require(copula)#
# require(mistr)#
nocores <- detectCores()-1#
registerDoMC(nocores)#
print(nocores)#
#
n <- c(100,1000)#
nMC <- 1000#
dgp <- 1#
if (dgp==1) b <- seq(0,5,length=5)#
#
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rres <- NULL#
    for (mc in 1:nMC) {#
        if (dgp==1) {#
            X <- rnorm(params$n[i])#
            Y <- params$b[i]*pnorm(X) + rnorm(params$n[i])#
        }#
        tmp <- rreg(Y, X)#
        rres <- rbind(rres,unlist(tmp))#
    }#
    rres <- as.data.frame(rres)#
    rbind(c(n=params$n[i], b=params$b[i], method="emp", sd=sd(rres$rhohat)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="OLS", sd=mean(rres$se)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="White", sd=mean(rres$hc0)*sqrt(params$n[i])))#
}#
#
res <- as.data.frame(res)#
res$sd <- as.double(res$sd)#
res$b <- as.double(res$b)#
res$n <- paste("n=",res$n,sep="")#
#
save.image("workspace.RData")#
#
library("lattice")#
pdf(file="ols_on_rank.pdf",width=12,height=8)#
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)#
dev.off()
rreg <- function(Y, X) {#
    # FXn <- ecdf(X)#
    # RX <- FXn(X)      #
    RX <- xrank(X)#
    res <- lm(Y ~ RX)#
    rhohat <- coef(summary(res))[2,1]#
    se <- coef(summary(res))[2,2]#
    hc0 <- sqrt(vcovHC(res, type="HC0")[2,2])#
    return(list(rhohat=rhohat,se=se,hc0=hc0))#
}#
#
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
    if (na.rm) x <- x[!is.na(x)]#
    return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}#
#
# setwd("/home/dwilhelm/rrreg/sim")#
#
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
# require(copula)#
# require(mistr)#
nocores <- detectCores()-1#
registerDoMC(nocores)#
print(nocores)#
#
n <- c(100,1000)#
nMC <- 1000#
dgp <- 1#
if (dgp==1) b <- seq(0,5,length=5)#
#
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rres <- NULL#
    for (mc in 1:nMC) {#
        if (dgp==1) {#
            X <- rnorm(params$n[i])#
            Y <- params$b[i]*pnorm(X) + rnorm(params$n[i])#
        }#
        tmp <- rreg(Y, X)#
        rres <- rbind(rres,unlist(tmp))#
    }#
    rres <- as.data.frame(rres)#
    rbind(c(n=params$n[i], b=params$b[i], method="emp", sd=sd(rres$rhohat)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="OLS", sd=mean(rres$se)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="White", sd=mean(rres$hc0)*sqrt(params$n[i])))#
}#
#
res <- as.data.frame(res)#
res$sd <- as.double(res$sd)#
res$b <- as.double(res$b)#
res$n <- paste("n=",res$n,sep="")#
#
save.image("workspace.RData")#
#
library("lattice")#
pdf(file="ols_on_rank.pdf",width=12,height=8)#
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)#
dev.off()
rreg <- function(Y, X) {#
    FXn <- ecdf(X)#
    RX <- FXn(X)        #
    # RX <- xrank(X)#
    res <- lm(Y ~ RX)#
    rhohat <- coef(summary(res))[2,1]#
    se <- coef(summary(res))[2,2]#
    hc0 <- sqrt(vcovHC(res, type="HC0")[2,2])#
    return(list(rhohat=rhohat,se=se,hc0=hc0))#
}#
#
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
    if (na.rm) x <- x[!is.na(x)]#
    return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}#
#
# setwd("/home/dwilhelm/rrreg/sim")#
#
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
# require(copula)#
# require(mistr)#
nocores <- detectCores()-1#
registerDoMC(nocores)#
print(nocores)#
#
n <- c(100,1000)#
nMC <- 10000#
dgp <- 1#
if (dgp==1) b <- seq(0,5,length=10)#
#
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rres <- NULL#
    for (mc in 1:nMC) {#
        if (dgp==1) {#
            X <- rnorm(params$n[i])#
            Y <- params$b[i]*pnorm(X) + rnorm(params$n[i])#
        }#
        tmp <- rreg(Y, X)#
        rres <- rbind(rres,unlist(tmp))#
    }#
    rres <- as.data.frame(rres)#
    rbind(c(n=params$n[i], b=params$b[i], method="emp", sd=sd(rres$rhohat)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="OLS", sd=mean(rres$se)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="White", sd=mean(rres$hc0)*sqrt(params$n[i])))#
}#
#
res <- as.data.frame(res)#
res$sd <- as.double(res$sd)#
res$b <- as.double(res$b)#
res$n <- paste("n=",res$n,sep="")#
#
save.image("workspace.RData")#
#
library("lattice")#
pdf(file="ols_on_rank.pdf",width=12,height=8)#
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)#
dev.off()
rreg <- function(Y, X) {#
    # FXn <- ecdf(X)#
    # RX <- FXn(X)      #
    RX <- xrank(X)#
    res <- lm(Y ~ RX)#
    rhohat <- coef(summary(res))[2,1]#
    se <- coef(summary(res))[2,2]#
    hc0 <- sqrt(vcovHC(res, type="HC0")[2,2])#
    return(list(rhohat=rhohat,se=se,hc0=hc0))#
}#
#
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
    if (na.rm) x <- x[!is.na(x)]#
    return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}#
#
# setwd("/home/dwilhelm/rrreg/sim")#
#
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
# require(copula)#
# require(mistr)#
nocores <- detectCores()-1#
registerDoMC(nocores)#
print(nocores)#
#
n <- c(100,1000)#
nMC <- 10000#
dgp <- 1#
if (dgp==1) b <- seq(0,5,length=10)#
#
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rres <- NULL#
    for (mc in 1:nMC) {#
        if (dgp==1) {#
            X <- rnorm(params$n[i])#
            Y <- params$b[i]*pnorm(X) + rnorm(params$n[i])#
        }#
        tmp <- rreg(Y, X)#
        rres <- rbind(rres,unlist(tmp))#
    }#
    rres <- as.data.frame(rres)#
    rbind(c(n=params$n[i], b=params$b[i], method="emp", sd=sd(rres$rhohat)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="OLS", sd=mean(rres$se)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="White", sd=mean(rres$hc0)*sqrt(params$n[i])))#
}#
#
res <- as.data.frame(res)#
res$sd <- as.double(res$sd)#
res$b <- as.double(res$b)#
res$n <- paste("n=",res$n,sep="")#
#
save.image("workspace.RData")#
#
library("lattice")#
pdf(file="ols_on_rank.pdf",width=12,height=8)#
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)#
dev.off()
rreg <- function(Y, X) {#
    FXn <- ecdf(X)#
    RX <- FXn(X)        #
    # RX <- xrank(X)#
    res <- lm(Y ~ RX)#
    rhohat <- coef(summary(res))[2,1]#
    se <- coef(summary(res))[2,2]#
    hc0 <- sqrt(vcovHC(res, type="HC0")[2,2])#
    return(list(rhohat=rhohat,se=se,hc0=hc0))#
}#
#
xrank <- function(x, best=TRUE, na.rm=FALSE) {#
    if (na.rm) x <- x[!is.na(x)]#
    return(best*(colSums(outer(x,x,'>'))+1) + (1-best)*(colSums(outer(x,x,'<'))+1))#
}#
#
# setwd("/home/dwilhelm/rrreg/sim")#
#
set.seed(100)#
library(sandwich)#
library(MASS)#
library(doMC)#
# require(copula)#
# require(mistr)#
nocores <- detectCores()-1#
registerDoMC(nocores)#
print(nocores)#
#
n <- c(100,1000)#
nMC <- 10000#
dgp <- 1#
if (dgp==1) b <- seq(0,5,length=10)#
#
params <- expand.grid(n=n, b=b)#
nparams <- nrow(params)#
#
res <- foreach (i=1:nparams, .combine=rbind) %dopar% {#
    rres <- NULL#
    for (mc in 1:nMC) {#
        if (dgp==1) {#
            X <- rnorm(params$n[i])#
            Y <- params$b[i]*pnorm(X) + rnorm(params$n[i])#
        }#
        tmp <- rreg(Y, X)#
        rres <- rbind(rres,unlist(tmp))#
    }#
    rres <- as.data.frame(rres)#
    rbind(c(n=params$n[i], b=params$b[i], method="empirical", sd=sd(rres$rhohat)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="OLS", sd=mean(rres$se)*sqrt(params$n[i])),#
            c(n=params$n[i], b=params$b[i], method="White", sd=mean(rres$hc0)*sqrt(params$n[i])))#
}#
#
res <- as.data.frame(res)#
res$sd <- as.double(res$sd)#
res$b <- as.double(res$b)#
res$n <- paste("n=",res$n,sep="")#
#
save.image("workspace.RData")#
#
library("lattice")#
pdf(file="ols_on_rank.pdf",width=12,height=8)#
xyplot(sd ~ b | n, groups = ~ method, data = res, type = "b", auto.key=TRUE)#
dev.off()
?replicate
library(devtools)
load_all()
document()
test()
load_all()
document()
test()
Y <- rnorm(100)
X <- rnorm(100)
Z <- rnorm(100)
a <- 0.5
ckertype="gaussian"
K <- getKernel(ckertype)
stat="CvM"
compDMStat <- function(ybar, abar) computeDMStat_1D(ybar, c(X), c(Z), a=abar, K=K, stat=stat)
res <- compDMStat(Y, a)
res
teststat <- res$teststat
epsilonhat <- res$epsilonhat
Yhat <- res$Yhat
ahat <- res$a
compDMStat(Yhat+epsilonhat*rMammen(length(Y)), ahat)
teststatb <- replicate(B, compDMStat(Yhat+epsilonhat*rMammen(length(Y)), ahat))
B=100
teststatb <- replicate(B, compDMStat(Yhat+epsilonhat*rMammen(length(Y)), ahat))
teststatb
teststatb <- replicate(B, compDMStat(Yhat+epsilonhat*rMammen(length(Y)), ahat)$teststat)
cv <- quantile(teststatb, 1-size, na.rm=TRUE)
teststatb
size <- 0.05
cv <- quantile(teststatb, 1-size, na.rm=TRUE)
Fn <- ecdf(teststatb)
pval <- 1-Fn(teststat)
pval
load_all()
test()
###########
## SETUP ###
############
#
rm(list = ls())#
SAVE <- TRUE#
model <- "Kotlarski"#
mfun <- "quad"#
# setwd("~/work/Documents/projects/testing_ME/sim/trunk")#
# setwd("/Users/uctpdwi/Dropbox/work/sync/Documents/projects/testing_ME/sim/trunk")#
# setwd(paste("/home/uctpdwi/testing_ME/",model,sep=""))#
# source("delman.r")#
library(doMC)#
library(foreach)#
#
# data-generating process#
#
    dgp <- function(nobs=1000, beta=1, gammaX=1, gammaZ=1, sd.eta=0.5, model="Kotlarski") {#
        if (mfun=="sine") m <- function(x) return(sin(pi*x/2))#
        if (mfun=="hump") {#
            m <- function(x) {#
                m1 <- sin(pi*x)#
                m2 <- -sin(2*pi*x)/(2^2)#
                m3 <- sin(3*pi*x)/(3^2)#
                m4 <- -sin(4*pi*x)/(4^2)#
                return(m1+m2+m3+m4) #
            }#
        }#
        if (mfun=="quad") m <- function(x) return(x^2+x/2)#
        if (model=="DM") {#
            X <- runif(nobs)#
            Z <- runif(nobs)#
            U <- rnorm(nobs)#
            m <- function(x) return(1+sin(10*x))#
            Y <- m(X) + beta*sin(gammaZ*Z) + U#
        }#
#
        if (model=="quad") {#
            Xstar <- runif(nobs)#
            # X <- rnorm(nobs)#
            # Z <- rnorm(nobs)#
            # Y <- sd.eta*Z + X + rnorm(nobs, 0, sd.err)#
            D <- rbinom(nobs, 1, beta)#
            X <- Xstar + D*rnorm(nobs, 0, sd.eta)#
            Z <- -(Xstar-1)^2 + rnorm(nobs, 0, 0.2)#
            Y <- m(Xstar) + rnorm(nobs, 0, 0.2) #
        }#
#
        if (model=="Kotlarski") {#
            Xstar <- runif(nobs)#
            # X <- rnorm(nobs)#
            # Z <- rnorm(nobs)#
            # Y <- sd.eta*Z + X + rnorm(nobs, 0, sd.err)#
            D <- rbinom(nobs, 1, beta)#
            X <- Xstar + D*rnorm(nobs, 0, sd.eta)#
            Z <- Xstar + rnorm(nobs, 0, 0.3)#
            Y <- m(Xstar) + rnorm(nobs, 0, 0.5) #
        }#
#
        if (model=="nonclass") {#
            Xstar <- runif(nobs)#
            # X <- rnorm(nobs)#
            # Z <- rnorm(nobs)#
            # Y <- sd.eta*Z + X + rnorm(nobs, 0, sd.err)#
            D <- rbinom(nobs, 1, beta)#
            X <- Xstar + D*rnorm(nobs, 0, sd.eta)*exp(-abs(Xstar-1/2))#
            Z <- Xstar + rnorm(nobs, 0, 0.3)*exp(-abs(Xstar-1/2))#
            Y <- m(Xstar) + rnorm(nobs, 0, 0.5) #
        }#
#
        if (model=="nonclass2") {#
            Xstar <- runif(nobs)#
            # X <- rnorm(nobs)#
            # Z <- rnorm(nobs)#
            # Y <- sd.eta*Z + X + rnorm(nobs, 0, sd.err)#
            D <- rbinom(nobs, 1, beta)#
            X <- Xstar + D*rnorm(nobs, 0, sd.eta)*exp(-abs(Xstar-1/2))#
            Z <- Xstar + rnorm(nobs, 0, 0.3)#
            Y <- m(Xstar) + rnorm(nobs, 0, 0.5) #
        }#
#
        if (model=="panel") {#
            X1star <- runif(nobs)#
            X2star <- 1.5*X1star + rnorm(nobs, 0, 0.5)#
            # X <- rnorm(nobs)#
            # Z <- rnorm(nobs)#
            # Y <- sd.eta*Z + X + rnorm(nobs, 0, sd.err)#
            D <- rbinom(nobs, 1, beta)#
            X <- X2star + D*rnorm(nobs, 0, sd.eta)#
            Z <- X1star + rnorm(nobs, 0, 0.5)#
            Y <- m(X2star) + rnorm(nobs, 0, 0.5)    #
        }#
        return(data.frame(Y=Y,X=X,Z=Z))#
    }#
# simulate power#
    testpower <- function(nrep=100, size=0.05, test=c("DM opt", "DM-", "DM"), a=NA, ...) {#
        rej <- matrix(rep(NA, length(test) * nrep), ncol = length(test))#
        colnames(rej) <- test#
#
        # find optimal bandwidth#
        if (is.na(a) & ("DM opt" %in% test)) {#
            a <- rep(0,5)#
            for (cv in 1:5) {#
                dat <- dgp(...)#
                Y <- dat$Y^(1+(model=="hump"))#
                X <- dat$X#
                a[cv] <- npregbw(Y~X)$bw#
            }#
            aopt <- median(a)#
        }#
        # MC loop#
        for (i in 1:nrep) {#
            dat <- dgp(...)#
            n <- length(dat$Y)#
            compute_rej <- function(test) {#
                test <- match.arg(test, c("DM opt", "DM-", "DM", "DM+", "t"))#
                res <- switch(test,#
                    "DM opt"        = DMTest(Y=dat$Y^(1+(model=="hump")), X=dat$X, Z=dat$Z, size=size, a=aopt, ckertype="epanechnikov"),#
                    "DM-"       = DMTest(Y=dat$Y^(1+(model=="hump")), X=dat$X, Z=dat$Z, size=size, a=0.1*n^(-1/3), ckertype="epanechnikov"),#
                    "DM"    = DMTest(Y=dat$Y^(1+(model=="hump")), X=dat$X, Z=dat$Z, size=size, a=0.2*n^(-1/3), ckertype="epanechnikov"),#
                    "DM+"   = DMTest(Y=dat$Y^(1+(model=="hump")), X=dat$X, Z=dat$Z, size=size, a=0.5*n^(-1/3), ckertype="epanechnikov"),#
                    "t" = ttest(Y=dat$Y, X=dat$X, Z=dat$Z, size=size))#
                return(res$rej)#
            }#
            rej[i,] <- sapply(test, compute_rej)#
        }#
        return(colMeans(rej))#
    }#
# simulation loop#
#
    simulation <- function(nobs=100, sd.eta=seq(0,2,length=10), gammaZ=c(0.1,1), beta=c(0.1,1), test=c("DM opt", "DM-", "DM"), a=NA, ...) {#
        # simulate power of the tests#
        print("simulate the power of the tests ...")#
        prs <- expand.grid(nobs=nobs,sd.eta=sd.eta, gammaZ=gammaZ, beta=beta)#
        nprs <- nrow(prs)#
        ntest <- length(test)#
        registerDoMC(detectCores()-(1-SAVE))#
        pow <- matrix(rep(NA, ntest * nprs), ncol=ntest)#
        # pb <- txtProgressBar(min = 1, max = nprs, style = 3)#
        pow <- foreach (i=1:nprs, .combine=rbind) %dopar% {#
            # print(setTxtProgressBar(pb, i))#
            sink("log.txt", append=TRUE)#
            print(paste(i, "/", nprs))#
            testpower(test=test, nobs=prs$nobs[i], beta=prs$beta[i], gammaZ=prs$gammaZ[i], sd.eta=prs$sd.eta[i], a=a, ...)#
        }#
        # close(pb)#
        # dev.off()#
        # construct return value for power simulations#
        rvalpow <- data.frame()#
        for(i in 1:ntest) rvalpow <- rbind(rvalpow, prs)#
        rvalpow$test <- gl(ntest, nprs, labels = test)#
        rvalpow$power <- as.vector(pow)#
        rvalpow$sd.eta <- rep(factor(prs$sd.eta), ntest)#
        rvalpow$gammaZ <- rep(factor(prs$gammaZ), ntest)#
        rvalpow$beta <- rep(factor(prs$beta), ntest)#
        rvalpow$nobs <- rep(factor(prs$nobs), ntest)#
        return(rvalpow)#
    }
set.seed(1090)#
starting_time <- proc.time()#
sc_sim <- simulation(nrep=100, nobs=200, beta=seq(0,1,length=5), sd.eta=c(0.2,0.5,1), gammaZ=1, test=c("DM"), a=NA, model=model)#
# sc_sim <- simulation(nrep=1000, nobs=c(200,500), beta=seq(0,1,length=5), sd.eta=c(0.2,0.5,1), gammaZ=1, test=c("t", "DM-", "DM", "DM+"), a=NA, model=model)#
print((proc.time()-starting_time)[1])
ls()
load_all()
ls()
getKernel()
set.seed(1090)#
starting_time <- proc.time()#
sc_sim <- simulation(nrep=100, nobs=200, beta=seq(0,1,length=5), sd.eta=c(0.2,0.5,1), gammaZ=1, test=c("DM"), a=NA, model=model)#
# sc_sim <- simulation(nrep=1000, nobs=c(200,500), beta=seq(0,1,length=5), sd.eta=c(0.2,0.5,1), gammaZ=1, test=c("t", "DM-", "DM", "DM+"), a=NA, model=model)#
print((proc.time()-starting_time)[1])
testpower <- function(nrep=100, size=0.05, test=c("DM opt", "DM-", "DM"), a=NA, ...) {#
        rej <- matrix(rep(NA, length(test) * nrep), ncol = length(test))#
        colnames(rej) <- test#
#
        # find optimal bandwidth#
        if (is.na(a) & ("DM opt" %in% test)) {#
            a <- rep(0,5)#
            for (cv in 1:5) {#
                dat <- dgp(...)#
                Y <- dat$Y^(1+(model=="hump"))#
                X <- dat$X#
                a[cv] <- npregbw(Y~X)$bw#
            }#
            aopt <- median(a)#
        }#
        # MC loop#
        for (i in 1:nrep) {#
            dat <- dgp(...)#
            n <- length(dat$Y)#
            compute_rej <- function(test) {#
                test <- match.arg(test, c("DM opt", "DM-", "DM", "DM+", "t"))#
                res <- switch(test,#
                    "DM opt"        = DMTest(Y=dat$Y^(1+(model=="hump")), X=dat$X, Z=dat$Z, size=size, a=aopt, ckertype="gaussian"),#
                    "DM-"       = DMTest(Y=dat$Y^(1+(model=="hump")), X=dat$X, Z=dat$Z, size=size, a=0.1*n^(-1/3), ckertype="gaussian"),#
                    "DM"    = DMTest(Y=dat$Y^(1+(model=="hump")), X=dat$X, Z=dat$Z, size=size, a=0.2*n^(-1/3), ckertype="gaussian"),#
                    "DM+"   = DMTest(Y=dat$Y^(1+(model=="hump")), X=dat$X, Z=dat$Z, size=size, a=0.5*n^(-1/3), ckertype="gaussian"),#
                    "t" = ttest(Y=dat$Y, X=dat$X, Z=dat$Z, size=size))#
                return(res$rej)#
            }#
            rej[i,] <- sapply(test, compute_rej)#
        }#
        return(colMeans(rej))#
    }
## run simulation#
set.seed(1090)#
starting_time <- proc.time()#
sc_sim <- simulation(nrep=100, nobs=200, beta=seq(0,1,length=5), sd.eta=c(0.2,0.5,1), gammaZ=1, test=c("DM"), a=NA, model=model)#
# sc_sim <- simulation(nrep=1000, nobs=c(200,500), beta=seq(0,1,length=5), sd.eta=c(0.2,0.5,1), gammaZ=1, test=c("t", "DM-", "DM", "DM+"), a=NA, model=model)#
print((proc.time()-starting_time)[1])
## numerical summary#
tab <- xtabs(power ~ sd.eta + beta + nobs + test, data = sc_sim)#
restable <- ftable(tab, row.vars = c("nobs", "sd.eta", "test"), col.vars = "beta")#
print(restable)
library("lattice")
bwtheme <- standard.theme("pdf", color=FALSE)
xyplot(power ~ beta |  nobs + sd.eta, groups = ~ test, data = sc_sim, type = "b", ylim=c(-0.1,1.1), ylab="", main="rejection probability", auto.key=list(space="right", cex.title=1, lines=TRUE, points=TRUE), par.settings=bwtheme)
load_all()
DMTest
## run simulation#
set.seed(1090)#
starting_time <- proc.time()#
sc_sim <- simulation(nrep=100, nobs=200, beta=seq(0,1,length=5), sd.eta=c(0.2,0.5,1), gammaZ=1, test=c("DM"), a=NA, model=model)#
# sc_sim <- simulation(nrep=1000, nobs=c(200,500), beta=seq(0,1,length=5), sd.eta=c(0.2,0.5,1), gammaZ=1, test=c("t", "DM-", "DM", "DM+"), a=NA, model=model)#
print((proc.time()-starting_time)[1])
tab <- xtabs(power ~ sd.eta + beta + nobs + test, data = sc_sim)#
restable <- ftable(tab, row.vars = c("nobs", "sd.eta", "test"), col.vars = "beta")#
print(restable)
array(dim=c(2,3,4))
X
X <- rnorm(100)
Z <- rnorm(100)
Y <- X+Z+rnorm(100)
a
a <- 0.5
K=dnorm
stat="CvM"
n <- length(Y)
n
Kij <- K(outer(X,X,"-")/a)/a
fhat <- colMeans(Kij)
compTn <- function(y,x,z) {#
        Y.mat <- matrix(rep(Y<=y,n), nrow=n, byrow=FALSE)   #
        Yhat <- colMeans(Y.mat*Kij) / fhat#
        epsilonhat <- Y-Yhat#
        return(mean(epsilonhat*(X<=x)*(Z<=z)*fhat))#
    }
Tn.vals <- mapply(compTn, y=Y, x=X, z=Z)
Tn.vals
fhat
compTn(Y[1],X[1],Z[1])
compTn(Y[2],X[2],Z[2])
library(devtools)
install_github("ericstrobl/RCIT")
library(RCIT)
?RCIT
RCIT(rnorm(1000),rnorm(1000),rnorm(1000))
RCIT(rnorm(1000),rnorm(1000),rnorm(1000))
RCIT(rnorm(1000),rnorm(1000),rnorm(1000))
RCIT(rnorm(1000),rnorm(1000),rnorm(1000))
RCIT(rnorm(1000),rnorm(1000),rnorm(1000))
RCIT(rnorm(1000),rnorm(1000),rnorm(1000))
RCIT(rnorm(1000),rnorm(1000),rnorm(1000))
RCIT(rnorm(1000),rnorm(1000),rnorm(1000))
RCIT(rnorm(1000),rnorm(1000),rnorm(1000))
RCIT(rnorm(1000),rnorm(1000),rnorm(1000))
RCIT(rnorm(1000),rnorm(1000),rnorm(1000))
RCIT(rnorm(1000),rnorm(1000),rnorm(1000))
RCIT(rnorm(1000),rnorm(1000),rnorm(1000))
RCIT(rnorm(1000),rnorm(1000),rnorm(1000))
RCIT(rnorm(1000),rnorm(1000),rnorm(1000))
RCIT(rnorm(1000),rnorm(1000),rnorm(1000))
RCoT(rnorm(1000),rnorm(1000),rnorm(1000))
RCoT(rnorm(1000),rnorm(1000),rnorm(1000))
RCoT(rnorm(1000),rnorm(1000),rnorm(1000))
X
RCoT(X,Y,Z)
